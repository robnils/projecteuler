// ProjectEuler.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <iostream>
#include <string>
#include <fstream>

size_t SumOfAllNumbersBelow1000();
size_t SumOfEvenTermsInFibonacciSequenceLessThan4Million();
bool is_prime(unsigned long long int number);
unsigned long long int LargestPrimeFactorOf(unsigned long long int number);
bool is_pallindrome(size_t number);
size_t LargestPallindromeProductOfTwo3DigitNumbers();

int main()
{
	std::cout << "*** Results ***\n";
	/*
	std::cout << "Problem 1: " << SumOfAllNumbersBelow1000() << std::endl;
	std::cout << "Problem 2: " << SumOfEvenTermsInFibonacciSequenceLessThan4Million() << std::endl;
	std::cout << "Problem 3: " << LargestPrimeFactorOf(600851475143) << std::endl;
	*/
	std::cout << "Problem 4: " << LargestPallindromeProductOfTwo3DigitNumbers() << std::endl;
	return 0;
}

// Problem 1
// Find the sum of all the multiples of 3 or 5 below 1000.

size_t SumOfAllNumbersBelow1000()
{
	size_t sum = 0;

	for (size_t multiple = 0; multiple < 1000; multiple++)
	{
		if ((multiple % 3 == 0) || (multiple % 5 == 0))
		{
			sum += multiple;
		}
	}
	return sum;
}

/*** End of Problem 1 **/

// Problem 2
// Each new term in the Fibonacci sequence is generated by adding the previous two terms. 
// By starting with 1 and 2, the first 10 terms will be:
// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
// By considering the terms in the Fibonacci sequence whose values do not exceed four million, 
// find the sum of the even - valued terms.

size_t SumOfEvenTermsInFibonacciSequenceLessThan4Million()
{
	size_t x_prev = 1, x = 2, x_next = x;
	size_t upper_limit = 4000000;

	size_t sum = 0;

	while (x_next < upper_limit)
	{
		// Calculate sum of even-valued Fibonacci Sequence
		if ((x % 2) == 0)
		{
			sum += x;
		}

		// Calculate terms of Fiibonacci Sequence
		x_next = x + x_prev;
		x_prev = x;
		x = x_next;
	}
	return sum;
}

/*** End of Problem 2 ***/

// Problem 3
// The prime factors of 13195 are 5, 7, 13 and 29.
// What is the largest prime factor of the number 600851475143 ?

// Tests whether "number" is prime or not. 
bool is_prime(unsigned long long int  number)
{
	bool is_prime = true;
	for (unsigned long long int i = 2; i < number; i++)
	{
		if ((number % i) == 0)
		{
			is_prime = false;
			break;
		}
	}
	return is_prime;
}

unsigned long long int LargestPrimeFactorOf(unsigned long long int number)
{
	// Test prime
	//size_t number = 12;
	unsigned long long int factor_1 = 1;
	unsigned long long int factor_2 = 1;

	unsigned long long int p_factor_1 = 1;
	unsigned long long int p_factor_2 = 1;

	unsigned long long int largest_prime_factor = 1;
	std::string prime_yes = "prime";
	std::string prime_no = "not prime";

	// Get factors 
	for (unsigned long long int i = 2; i < number; i++)
	{
		// Display something to show the program is working
		if (i % 10000000 == 0)
		{
			std::cout << "Testing " << i << "..." << std::endl;
		}
		// If number is a factor
		if ((number % i) == 0)
		{
			unsigned long long int factor_1 = i;
			unsigned long long int factor_2 = (number / i);

			std::cout << "Current factor: " << factor_1;
			bool res1 = is_prime(factor_1);
			p_factor_1 = (res1) ? factor_1 : p_factor_1;
			std::cout << "\t" << ((res1) ? prime_yes : prime_no);

			std::cout << "\nCurrent factor: " << factor_2;
			bool res2 = is_prime(factor_2);
			p_factor_2 = (res2) ? factor_2 : p_factor_2;
			std::cout << "\t" << ((res2) ? prime_yes : prime_no);

			// If prime factor is the current largest
			largest_prime_factor = (p_factor_1 > largest_prime_factor) ? p_factor_1 : largest_prime_factor;
			largest_prime_factor = (p_factor_2 > largest_prime_factor) ? p_factor_2 : largest_prime_factor;

			std::cout << "\nLargest: " << largest_prime_factor << std::endl << std::endl;
		}
	}
	return largest_prime_factor;
}

/*** End of Problem 3 **/

// Problem 4
// A palindromic number reads the same both ways.The largest palindrome made from the
// product of two 2 - digit numbers is 9009 = 91 × 99.
// Find the largest palindrome made from the product of two 3 - digit numbers.

bool is_pallindrome(size_t number)
{
	std::string s = std::to_string(number);
	int len = s.length();

	// The upper bound of the loop below is the middle point of the 
	// string. The if-condition takes care of the middle value (irrelevant for our purposes)
	// in the event of an odd number.
	size_t upper_bound = (len % 2 == 0) ? len / 2 : (len - 1) / 2;

	bool is_pallindrome = true;
	for (size_t i = 0; i < upper_bound; i++)
	{
		if (s[i] != s[len - i - 1])
		{
			is_pallindrome = false;
			break;
		}
	}
	return is_pallindrome;
}

size_t LargestPallindromeProductOfTwo3DigitNumbers()
{
	std::ofstream log;
	log.open("problem_4.txt");
	
	size_t digit_1 = 999, digit_2 = 998, largest_pallindrome;

	// 999*999 = 998001 != pallindrome
	// Note: products on integers is commutative; hence,x*y=y*x.
	// Also, we start at the maximum bound; 999*998 as it is the 
	// largest pallindrome we seek. This is far faster than starting at 1.
	for (size_t i = 999; i > 99; i--)
	{
		int product = digit_1*digit_2;

		log << "Testing " << product << "...";
		if (is_pallindrome(product))
		{
			largest_pallindrome = product;
			log << "...Yes!\n";
			break;
		}
		log << "...No.\n";

		digit_1--;
		digit_2--;
	}
	log.close();
	return largest_pallindrome;
}

/*** End of Problem 4 **/

